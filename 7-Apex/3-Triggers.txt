
 üü• What is Apex Triggers?
----------------------
- it is an automation tool that allows you to perform custom actions before or after DML operations.
  like validation, updating related records, or automating business processes.


üü• Types of Triggers:
------------------
- Before Triggers: used to perform custom actions before the record is saved to the database like validation rules.
- After Triggers: used to perform custom actions after the record is saved to the database 
                  like sending an email notification or updating related records.

üü• Trigger Events:
-----------------
        1- Before Insert : Trigger fires before the record is inserted into the database.
        2- Before Update : Trigger fires before the record is updated in the database.
        3- Before Delete : Trigger fires before the record is deleted from the database.
        4- After Insert : Trigger fires after the record is inserted into the database.
        5- After Update : Trigger fires after the record is updated in the database.
        6- After Delete : Trigger fires after the record is deleted from the database.
        7- After Undelete : Trigger fires after the record is recovered from the recycle bin.

 üü• Note: There is no before undelete trigger event in Salesforce
          - because the record is not active when it is in the recycle bin.
          - there is no context to perform actions before the record is recovered.
          - you can use after undelete trigger event to perform actions after the record is recovered like updating related records.
          - When a record is recovered from the recycle bin, it is considered as an insert operation.
          - When a record is deleted, it is moved to the recycle bin and can be recovered within 15 days.

üü• Trigger Context Variables:
----------------------------
- holds information about the trigger context like the new and old versions of the records, trigger events, etc.
- used to control the trigger logic based on the trigger events.

        üü• 1- Trigger.new :list of the new versions of the records being inserted or updated.
                          :Available in before insert, before update, after insert, and after update triggers.
                          :Not available in before delete, after delete because the record is being deleted.
                          : [ {Id=Id1, Name=R1}, {Id=Id2, Name=R2}, {Id=Id3, Name=R3} ]

        üü• 2- Trigger.old : list of the old versions of the records being updated or deleted.
                          : Available in before update, after update, before delete, and after delete triggers.
                          : Not available in before insert, after insert because the record is not saved yet.
                          : [ {Id=Id1, Name=R1}, {Id=Id2, Name=R2}, {Id=Id3, Name=R3} ]

      

        üü• 3- Trigger.newMap :map of key-value pairs where the key is the record ID and the value is the record itself.
                            :Available in before insert, before update, after insert, and after update triggers.
                            :Not available in before delete, after delete because the record is being deleted.
                            : [ {Id1=Record1}, {Id2=Record2}, {Id3=Record3} ]
                            : used to store and update related records.
                            : quick access to the record using the record ID.
                            : used to compare the old and new versions of the records.
        
             Example: Map<Id, Account> newAccountMap = Trigger.newMap;
          
        üü• 4- Trigger.oldMap : Returns a map of the old versions of the sObject records.
        üü• 5- Trigger.isInsert : Returns true if the trigger was fired due to an insert operation.
        üü• 6- Trigger.isUpdate : Returns true if the trigger was fired due to an update operation.
        üü• 7- Trigger.isDelete : Returns true if the trigger was fired due to a delete operation.
        üü• 8- Trigger.isBefore : Returns true if the trigger was fired before the record was saved.
        üü• 9- Trigger.isAfter : Returns true if the trigger was fired after the record was saved.
        üü• 10- Trigger.isExecuting : Returns true if the trigger is currently executing.
        üü• 11- Trigger.isUndelete : Returns true if the trigger was fired due to an undelete operation.


üü• Availability of Trigger.newMap and Trigger.oldMap Across Events
-------------------------------------------------------------
Trigger Event	Trigger.new		    Trigger.old		Modifiable?
                Trigger.newMap      Trigger.oldMap

before insert	‚úÖ Available	       ‚ùå Not Available	‚úÖ Yes, you can modify Trigger.new because the record is not saved yet
after insert	‚úÖ Available		   ‚ùå Not Available	‚ùå No because the record is already saved

before update	‚úÖ Available		   ‚úÖ Available	    ‚úÖ Yes, you can modify Trigger.new
after update	‚úÖ Available		   ‚úÖ Available		‚ùå No

before delete	‚ùå Not Available	   ‚úÖ Available		‚ùå No 
after delete	‚ùå Not Available	   ‚úÖ Available		‚ùå No

after undelete	‚úÖ Available	       ‚ùå Not Available	‚ùå No


üü• Note 1   - we can't access directly fields from Related objects in the trigger .
           - Trigger.new and Trigger.old contain only the fields of the current object.
           - Related objects' fields (lookups, master-detail relationships) are not automatically included.
           - To get related object fields, you must perform a SOQL query.

            Example:
            for (Case c : Trigger.new) {
                if (c.Account.Rating == 'Hot') {  // ‚ùå This will throw an error!
                    c.Priority = 'High';
                }
            }

           To access related object fields, you need to perform a SOQL query
           - Example:
                Set<Id> accountIds = new Set<Id>();
                for (Case c : Trigger.new) {
                    accountIds.add(c.AccountId);
                }
            Map<Id, Account> accounts = new Map<Id, Account>([SELECT Id, Rating FROM Account WHERE Id IN :accountIds]);
            for (Case c : Trigger.new) {
                if (accounts.get(c.AccountId).Rating == 'Hot') {
                    c.Priority = 'High';
                }
            }
    
üü• Note 2 : ‚úÖ Trigger.new and Trigger.newMap can only be modified in "before insert" and "before update" triggers.
            - In "after insert" and "after update" triggers, the records are already saved to the database, so they cannot be modified.
            - If you need to modify the records in "after insert" or "after update" triggers, you need to perform DML operations like update or insert.
            - In "before delete" and "after delete" triggers, the records are being deleted, so they cannot be modified.

            Example:
            - trigger CaseTrigger on Case (before update) {
                for (Case c : Trigger.new) {
                    if (c.Reason == 'Resolved' && c.Status != 'Closed') {
                        c.Status = 'Closed';  // ‚úÖ Allowed in before update
                    }
                }
            }
            trigger CaseTrigger on Case (after update) {
                for (Case c : Trigger.new) {
                    c.Status = 'Closed';  // ‚ùå Not Allowed in after update (DML required)
                }
            }

            solve this by using a separate update statement:
            trigger CaseTrigger on Case (after update) {
                List<Case> casesToUpdate = new List<Case>();
                for (Case c : Trigger.new) {
                    c.Status = 'Closed';  // ‚ùå Not Allowed in after update (DML required)
                    casesToUpdate.add(c);
                }
                update casesToUpdate;  // Perform DML operation to update the records
            }

üü• Note 3 : - in apex = is case-insensitive
            'Hello' == 'hello' // true
            'Hello' == 'HELLO' // true

           - you can use .equals() method to compare strings in a case-sensitive manner.
            'Hello'.equals('hello') // false

üü• Note 4 : we can't use = in the if condition we should use ==
            - Example:
                if (c.Reason = 'Resolved') {  // ‚ùå This will assign 'Resolved' to c.Reason
                    c.Status = 'Closed';
                }
                
üü• Note 5 : - CreatedDate is not Writeable
           - to set the CreatedDate of a record, you need to use the Test.setCreatedDate method in a test class.
           - Example:
                Test.setCreatedDate(newCase.Id, Date.today().addDays(-8));  // Set CreatedDate to 8 days ago


üü• Note 6 : - You can use addError() method to prevent DML operations like insert, update, delete, or undelete if the record does not meet certain criteria.
            - Example:
                if (opp.CloseDate < Date.today()) {
                    opp.CloseDate.addError('Closing date cannot be in the past');  // Prevents save if CloseDate is in the past
                }     
----------------------------------------------------------------------------------------------------------------------------
üü™ Best Practices for Triggers:
-------------------------------
1- Bulkify the Code: 
    - handle multiple records at once to avoid hitting the governor limits.
    - Use collections like lists, sets, and maps to process records in bulk instead of one by one.
    - Avoid SOQL queries and DML operations inside loops.
    - use map to store and update related records.
2- Use Trigger Handler Classes:
   - Separate the trigger logic into seprate classe to make the code more reusable and easier to maintain.
3- Avoid SOQL Queries in Loops: Avoid querying the database inside loops to improve performance.
4- Use Context Variables to Control the Trigger Logic.
5- Write Unit Tests: Write unit tests to cover at least 75% of the trigger code to ensure it works as expected.

üü™ Note:
- use a synchronous process like Queueable Apex or Batch Apex for making callouts to external systems from triggers.
----------------------------------------------------------------------------------------------------------------------------
üü• AggregateResult in Salesforce:
---------------------------------
- is a data type used to store the result of an aggregate query like SUM, AVG, MIN, MAX, COUNT.
- stores the result of the aggregate query in a key-value pair format where the key is the alias of the aggregate function and the value is the result.
- behaves like a list of maps where each map represents the result of an aggregate query.
- should use .get() method to access the value of the aggregate result.
- should cast the value to the appropriate data type before using it.
-Snippet of the result of an aggregate query:
  {{totalAmount=1000.0}, {totalAmount=2000.0}, {totalAmount=3000.0}}

- Example:
    List<AggregateResult> results = [SELECT SUM(Amount) totalAmount FROM Opportunity];
    for(AggregateResult ar : results){
        Decimal totalAmount = (Decimal) ar.get('totalAmount');
    }


----------------------------------------------------------------------------------------------------------------------------
üü• When would you use a Trigger instead of Workflow, Process Builder, or Flows?
---------------------------------------------------------------------------
- When you need to perform complex logic and handle multiple records at once.
- When you need to update related records or perform cross-object operations.
- When you need to validate the data before saving it to the database.

------------------------------------------------------------------------------------------------------------------------------------------
üü™ Handle the null values in triggers
-------------------------------------
- Use null checks to avoid NullPointerException.
- Example:
    if (c.AccountId != null) {
        // Perform actions on the related Account
    }

 public class Question {
	public static boolean isContact(String strContactId){
		if( strContactId != null && strContactId.left(3)=='003'){
			return true; 
		}else{
			return false;

		}
	}
}

üü™ Trigger Frameworks?
--------------------
- set of best practices to organize and manage triggers in Salesforce.
1- Use a Trigger Handler Class to write the trigger logic.
2- Use trigger context variables to separate the trigger logic based on the trigger events.
3- Enforce a single trigger per object to avoid conflicts.

üü™ Trigger Recursion
--------------------
üîπ occurs when a trigger invokes itself over and over again.
üß® Common Causes:
    1- happens when triggers fire and make DML operations on the same object.
    2- happens when cross-object triggers are involved
       (e.g., an Account trigger updates Opportunities and the Opportunity trigger updates Accounts).

‚ö†Ô∏è Consequences
    1- Infinite loops.
    2- Governor limit exceptions (DML, CPU, SOQL, etc.)

‚úÖ How to Prevent It
    1- Use static flags to track if the trigger logic has already executed or not.

üü™ Example of Preventing Trigger Recursion due to DML on the Same Object
üß± Step 1: Create a Static Utility Class

    public class TriggerControl {
    public static Boolean hasRunAccountLogic = false;
    }
    
üîÅ Step 2: Update the Trigger

    trigger AccountTrigger on Account (after update) {
    if (!TriggerControl.hasRunAccountLogic) {
        TriggerControl.hasRunAccountLogic = true;
        AccountTriggerHandler.updateAccountName(Trigger.new);
    }
}

üîß Step 3: Handler Class (with DML on Account)

public class AccountTriggerHandler {
    public static void updateAccountName(List<Account> newAccounts) {
        List<Account> accountsToUpdate = new List<Account>();

        for (Account acc : newAccounts) {
            if (acc.Name != null && !acc.Name.endsWith(' - Updated')) {
                Account updatedAcc = new Account(Id = acc.Id);
                updatedAcc.Name = acc.Name + ' - Updated';
                accountsToUpdate.add(updatedAcc);
            }
        }

        if (!accountsToUpdate.isEmpty()) {
            update accountsToUpdate; // ‚úÖ Safe from recursion due to the static flag
        }
    }
}

üü™ Example of Preventing Trigger Recursion due to Cross-Object Updates
 - Step 1: Create a Static Controller Class

   public class TriggerControl {
     public static Boolean hasRunAccountLogic = false;
     public static Boolean hasRunOpportunityLogic = false;
    }

    - Step 2: Use the Flags in the Triggers
    trigger AccountTrigger on Account (after update) {
    if (!TriggerControl.hasRunAccountLogic) {
        TriggerControl.hasRunAccountLogic = true;
        AccountTriggerHandler.updateRelatedOpportunities(Trigger.newMap, Trigger.oldMap);
    }
}
    trigger OpportunityTrigger on Opportunity (after update) {
    if (!TriggerControl.hasRunOpportunityLogic) {
        TriggerControl.hasRunOpportunityLogic = true;
        OpportunityTriggerHandler.updateAccountRating(Trigger.new);
    }
}
üß† Important Notes"
      1- trigger on the Account and on the Opportunity object considered as a single transaction because 
         they are chained together.
      2- static variables are reset after the transaction is completed, so they will not persist across different transactions.


----------------------------------------------------------------------------------------------------------------------------
üü• Examples of Apex Trigger:
------------------------
üü• 1- Create a trigger to update the account name to uppercase before inserting the record.

Apex Trigger:
-------------
trigger AccountTrigger on Account (before insert, before update){
    if(Trigger.isBefore && (Trigger.isInsert || Trigger.isUpdate)){
        AccountTriggerHandler.updateAccountName(Trigger.new);
    }
}
Apex Trigger Handler Class:
----------------------------
public class AccountTriggerHandler {   
    public static void updateAccountName(list<Account> newAccounts){

        // ‚úÖloop through the newAccountList
        // ‚úÖcheck the account name is not null and not equal upper case
        // ‚úÖupdate the account name to be upper case
        
        for(Account newAccount:newAccounts){
            if(newAccount.Name != null && !newAccount.Name.equals(newAccount.Name.toUpperCase()) ){
                newAccount.Name = newAccount.Name.toUpperCase(); // ‚úÖ we can modify the record before insert and we dont have to make insert dml
            }
        } 
    }
}
Apex Trigger Test Class:
-------------------------
@isTest
public class AccountTriggerTest{
    
    @isTest
    private static void updateAccountNameTest(){
        // ‚úÖcreate test data
        Account newAcc = new Account(Name='bankofamerica');
        
        Test.startTest();
        insert newAcc;
        Test.stopTest();
        
        // ‚úÖquery inserted data  
        Account insertedAcc = [SELECT name FROM Account WHERE id= :newAcc.Id];
        System.assertEquals('BANKOFAMERICA',insertedAcc.Name,'Account name should be capital');  
    }
}
----------------------------------------------------------------------------------------------------------------------------
üü• 2-A sales team wants to ensure that no Opportunity is created with a closing date in the past.
   How would you enforce this with a trigger?

Apex Trigger:
-------------
trigger OpportunityTrigger on Opportunity (before insert, before update){
    if(Trigger.isBefore && (Trigger.isInsert || Trigger.isUpdate)){
        OpportunityTriggerHandler.validateClosingDate(Trigger.new);
    }
}
Apex Trigger Handler Class:
----------------------------
public class OpportunityTriggerHandler {
    public static void validateClosingDate(List<Opportunity> opps) {
        //loop on newOpps
        //check the close date if in the past
        //if true addError

        for (Opportunity opp : opps) {
            if (opp.CloseDate != null && opp.CloseDate < Date.today()) {
                opp.CloseDate.addError('Closing date cannot be in the past');  //‚úÖ Prevents save if CloseDate is in the past
            }
        }
    }
}

Apex Trigger Test Class:
-------------------------
@isTest
public class OpportunityTriggerTest {
    @isTest
    private static void testValidateClosingDate(){
        
        //create data
        Opportunity newOpp = new Opportunity();
        newOpp.Name = 'Test Opportunity';
        newOpp.CloseDate = Date.today().addDays(-1);  // Set closing date in the past
        
        Test.startTest();
        try{
            insert newOpp;
            System.assert(false, 'Opportunity with past closing date should not be inserted');
        }catch(DmlException e){
            System.assert(e.getMessage().contains('Closing date cannot be in the past'));
        }
        Test.stopTest();
    }
}
----------------------------------------------------------------------------------------------------------------------------
üü• 3-A company wants to automatically update the Case Status to 'Closed' if the Case Reason is set to "Resolved" 
    and the Case is older than 7 days .

    // create a trigger on the case when the case is inserted or updated
    // get the cases where the reason is resolved and the status is not closed
    // check if the case created date is older than 7 days
    // if true update the status to closed

Apex Trigger:
-------------
trigger CaseTrigger on Case(before insert, before update){
    if(Trigger.isBefore && (Trigger.isInsert || Trigger.isUpdate)){
        CaseTriggerHandler.updateCaseStatus(Trigger.new);
    }
}
Apex Trigger Handler Class:
----------------------------
public class CaseTriggerHandler { 
    public static void updateCaseStatus(List<Case> newCases) {
     list<Messaging.SingleEmailMessage> emails = new list<Messaging.SingleEmailMessage>();

        for (Case newCase : newCases) {
            if (newCase.Reason == 'Resolved' && newCase.Status != 'Closed' && 
                newCase.CreatedDate <= Date.today().addDays(-7)) { 
                newCase.Status = 'Closed';  // ‚úÖ Update the status to Closed without DML

                // Send email notification to Case Owner
                Messaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();
                email.setSubject('Case Closed Notification');
                email.setPlainTextBody('Your case has been closed.');
                email.setTargetObjectId(newCase.OwnerId);
                emails.add(email);
            }
        }
        if(!emails.isEmpty()){
            Messaging.sendEmail(emails);
        }
    }
}
Apex Trigger Test Class:
-------------------------
@isTest
public class CaseTriggerTest {
    @isTest
    private static void testUpdateCaseStatus() {
        
        Case newCase = new Case();
        newCase.Subject = 'Test Case';
        newCase.Reason = 'Resolved';
        newCase.Status = 'Open';
        insert newCase;

        Test.setCreatedDate(newCase.Id, Date.today().addDays(-8));  // Set CreatedDate to 8 days ago

        newCase.Reason = 'Resolved';
        update newCase;

        Case updatedCase = [SELECT Status FROM Case WHERE Id = :newCase.Id];
        System.assertEquals(updatedCase.Status, 'Closed', 'Case status should be Closed');
     
    }
}

----------------------------------------------------------------------------------------------------------------------------
üü• 4-A company wants to automatically set the "High Priority" checkbox to TRUE on a Case record if the Case
    is related to a VIP Customer.
    A VIP Customer is defined as an Account where the Rating is "Hot".

Apex Trigger:
-------------
trigger CaseTrigger on Case(before insert, before update){
    
    if(Trigger.isBefore && (Trigger.isInsert || Trigger.isUpdate)){
        CaseTriggerHandler.updateRelatedAccounts(Trigger.new);
    }
}
Apex Trigger Handler Class:
----------------------------
public class CaseTriggerHandler {
    
    public static void updateRelatedAccounts(List<Case> newCases) {
        
        // Collect Account IDs from new Cases (ensure AccountId is not null)
        Set<Id> accountIds = new Set<Id>();

        for (Case newCase : newCases) {
            if (newCase.AccountId != null) {
                accountIds.add(newCase.AccountId);
            }
        }
        
        // Exit early if no valid Account IDs
        if (accountIds.isEmpty()) {
            return;
        }

        // Query VIP Accounts (Rating = 'Hot')
        Map<Id, Account> vipAccountsMap = new Map<Id, Account>(
            [SELECT Id FROM Account WHERE Id IN :accountIds AND Rating = 'Hot']
        );

        // Exit early if no VIP accounts exist
        if (vipAccountsMap.isEmpty()) {
            return;
        }

        // Update Cases related to VIP Accounts
        for (Case newCase : newCases) {
            if (vipAccountsMap.containsKey(newCase.AccountId)) {
                newCase.Priority = 'High';
            }
        }
    }
}
Apex Trigger Test Class:
-------------------------
@isTest
public class CaseTriggerTest {
    @isTest
    private static void testUpdateRelatedAccounts() {
        
        Account vipAccount = new Account(Name = 'VIP Account', Rating = 'Hot');
        insert vipAccount;
        
        Case newCase = new Case(AccountId = vipAccount.Id);
        insert newCase;
        
        Test.startTest();
        Case updatedCase = [SELECT Priority FROM Case WHERE Id = :newCase.Id];
        System.assertEquals(updatedCase.Priority, 'High', 'Case priority should be High');
        Test.stopTest();
    }
}
----------------------------------------------------------------------------------------------------------------------------
üü• 5-A company wants to prevent the deletion of Account records that have related Opportunities.
    How would you implement this using a trigger?

Apex Trigger:
-------------
trigger AccountTrigger on Account (before delete){
    if(Trigger.isBefore && Trigger.isDelete){
        AccountTriggerHandler.preventAccountDeletion(Trigger.old);
    }
}
Apex Trigger Handler Class:
----------------------------
public class AccountTriggerHandler{  
    public static void preventDelteAccountWithRelatedOpps(List<Account> oldAccounts){
        Set<Id> accountIds = new Set<Id>();
        for(Account acc : oldAccounts){
            accountIds.add(acc.Id);
        }
        
        // Query Opportunities related to the Accounts
        Map<Id, Account> accountsWithOpps = new Map<Id, Account>([
                          SELECT Id
                          FROM Account
                          WHERE Id IN :accountIds AND Id IN (SELECT AccountId FROM Opportunity)
                       ]);

        // Prevent deletion of Accounts with related Opportunities
        for (Account acc : Trigger.old) {
            if (accountsWithOpportunities.containsKey(acc.Id)) {
                acc.addError('Cannot delete Account with related Opportunities.');
            }
        }

    }
}
Apex Trigger Test Class:
-------------------------
@isTest
public class AccountTriggerTest {

    @isTest
    private static void testPreventAccountDeletion(){ 
        Account newAcc = new Account();
        newAcc.Name = 'Test Account';
        insert newAcc;
        
        Opportunity newOpp = new Opportunity();
        newOpp.Name = 'Test Opportunity';
        newOpp.AccountId = newAcc.Id;
        insert newOpp;
        
        Test.startTest();
        try{
            delete newAcc;
        }catch(DmlException e){
            System.assert(e.getMessage().contains('Cannot delete account with related opportunities'));
        }
        Test.stopTest();
    }
}
----------------------------------------------------------------------------------------------------------------------------
üü• 6- Write an Apex trigger to update the Account Rating to 'Cold' if the Account has no related Opportunities.
   Account Rating should be 'Warm' if the Account has between 1 and 5 Opportunities,
   and 'Hot' if the Account has more than 5 Opportunities.

Apex Trigger:
-------------
trigger OpportunityTrigger on Opportunity(after insert, after update, after delete , after undelete){
    if(Trigger.isAfter && (Trigger.isInsert || Trigger.isUpdate || Trigger.isDelete || Trigger.isUndelete)){
        OpportunityTriggerHandler.updateAccountRating(Trigger.isDelete ? Trigger.old : Trigger.new);
    }
}
Apex Trigger Handler Class:
----------------------------
public class OpportunityTriggerHandler {
    
    public static void updateAccountRating(List<Opportunity> Opps){
        // Step 1: Collect Account Ids (Ignoring NULL values)
      Set<Id> accIds = new Set<Id>();
        for(Opportunity opp:opps){
            accIds.add(opp.AccountId);
        } 
        // Exit if no valid AccountIds
         if (accIds.isEmpty()) {
            return; 
        }     
         // Step 2: Get the number of related Opportunities per Account
        List<AggregateResult> RelatedOppsCount = [SELECT AccountId, COUNT(Id) numOfOpp
                                                  FROM Opportunity
                                                  WHERE AccountId IN:accIds
                                                  GROUP BY AccountId];
        
        // Step 3: Map AccountId to Opportunity Count
        map<Id, Integer> RelatedOppsCountMap = new Map<Id,Integer>();
        for(AggregateResult ar:RelatedOppsCount){
            Id accId = (Id) ar.get('AccountId');
            Integer oppCount = (Integer) ar.get('numOfOpp');
            RelatedOppsCountMap.put(accId,oppCount);
        }
            
         // Step 4: Fetch Accounts and Update Rating Only If Needed
        list<Account> relatedAccs = [SELECT name, id ,Rating FROM Account WHERE id IN:accIds];
        for(Account acc:relatedAccs){
            Integer count = RelatedOppsCountMap.get(acc.Id);
            String newRating;
            if(count == 0 || count == null){
                newRating = 'COLD';
            }
            else if (count >=1 && count <=5){
                newRating = 'WARM';
            }else{
                newRating = 'HOT';
            }
            // Only update if the Rating is different
            if (acc.Rating != newRating) {
                acc.Rating = newRating;
            }
        }
        update relatedAccs;
    }          
}
----------------------------------------------------------------------------------------------------------------------------
üü• 7- Write an Apex trigger to update the Account Rating to 'Warm' if the Account has between 1 and 5 Opportunities.   
  
Apex Trigger:
-------------
trigger OpportunityTrigger On Opportunity (after insert, after update, after delete ,after undelete){
    
    if(Trigger.isAfter && (Trigger.isInsert || Trigger.isDelete || Trigger.isUpdate || Trigger.isUndelete)){
        OpportunityTriggerHandler.updateAccountRating(Trigger.isDelete? Trigger.old : Trigger.new);
    }
}

Apex Trigger Handler Class:
----------------------------
public class OpportunityTriggerHandler {
    public static void updateAccountRating(List<Opportunity> Opps){  
      //get the accIds for each opportunity
      //calculate the num of opp per each account and get only 1>n>5
      //update the account.rating to 'warm'
      
      Set<Id> AccIds = new Set<Id>();
        for(Opportunity opp:opps){
            AccIds.add(opp.AccountId);
        }
      List<AggregateResult> numOfRelatedOpps = [SELECT AccountId, COUNT(Id)
                                                FROM Opportunity
                                                WHERE AccountId IN:AccIds 
                                                GROUP BY AccountId
                                                HAVING COUNT(Id) >= 1
                                                AND COUNT(Id) <= 5];
        
      map<Id, Account> accsToUpdate = new map<Id ,Account>();
        for(AggregateResult ar:numOfRelatedOpps){
            Id accId = (id) ar.get('AccountId');
            accsToUpdate.put(accId, new Account(Id = accId, Rating ='Warm'));
        }
        update accsToUpdate.values();  
  }
}
Apex Trigger Test Class:
-------------------------
@isTest
public class OpportunityTriggerTest {
    @isTest
    private static void testUpdateAccountRating(){ 
        Account newAcc = new Account();
        newAcc.Name = 'Test Account';
        insert newAcc;
        
        for(Integer i=0; i<3; i++){
            Opportunity newOpp = new Opportunity();
            newOpp.Name = 'Test Opportunity ' + i;
            newOpp.AccountId = newAcc.Id;
            insert newOpp;
        }
        
        Test.startTest();
        List<Account> updatedAccount = [SELECT Rating FROM Account WHERE Id = :newAcc.Id];
        System.assertEquals(updatedAccount.Rating, 'Warm', 'Account rating should be Warm');
        Test.stopTest();
    }
}  

----------------------------------------------------------------------------------------------------------------------------
üü• 8- When an Account‚Äôs status changes to ‚ÄòInactive‚Äô, all related Opportunities should be marked as ‚ÄòClosed Lost‚Äô.
   How would you accomplish this?

Apex Trigger:
-------------
trigger AccountTrigger on Account (after update){
    if(Trigger.isAfter && Trigger.isUpdate){
        AccountTriggerHandler.updateRelatedOpportunities(Trigger.newMap, Trigger.oldMap);
    }
}
Apex Trigger Handler Class:
----------------------------
public class AccountTriggerHandler {
    public static void updateRelatedOpportunities(Map<Id, Account> newAccounts, Map<Id, Account> oldAccounts){
       
        set<Id> inactiveAccountIds = new set<Id>();
        for(Id accId : newAccounts.keySet()){
            if(newAccounts.get(accId).Status__c == 'Inactive' && oldAccounts.get(accId).Status__c != 'Inactive'){
                inactiveAccountIds.add(accId);
            }
        }    
        if(!inactiveAccountIds.isEmpty()){
            List<Opportunity> oppsToUpdate = [SELECT Id, StageName FROM Opportunity WHERE AccountId IN :inactiveAccountIds AND StageName != 'Closed Lost'];
            for(Opportunity opp : oppsToUpdate){
                opp.StageName = 'Closed Lost';
            }
            if(!oppsToUpdate.isEmpty()){
                update oppsToUpdate;
            }            
        }  
}
Apex Trigger Test Class:
-------------------------
@isTest
public class AccountTriggerTest {
    @isTest
    private static void testUpdateRelatedOpportunities(){  
        Account newAcc = new Account();
        newAcc.Name = 'Test Account';
        newAcc.Status__c = 'Active';
        insert newAcc;  
        Opportunity newOpp = new Opportunity();
        newOpp.Name = 'Test Opportunity';
        newOpp.AccountId = newAcc.Id;
        newOpp.StageName = 'Prospecting';
        insert newOpp;     
        newAcc.Status__c = 'Inactive';
        update newAcc;      
        Opportunity updatedOpp = [SELECT StageName FROM Opportunity WHERE Id = :newOpp.Id];
        System.assertEquals(updatedOpp.StageName, 'Closed Lost', 'Opportunity stage should be Closed Lost');
    }
}     

----------------------------------------------------------------------------------------------------------------------------
üü• 9- Trigger to Automatically Set a Contact‚Äôs Status to "Inactive" When the Related Account is Marked as "Inactive"

 
 




*/
